import json
import uuid
from collections import defaultdict
from enum import StrEnum
from typing import Any, Dict, List, Optional, Set

from pydantic import BaseModel, Field


class MarkdownSection(BaseModel):
    """Represents a section in a Markdown document."""

    id: str = Field(default_factory=lambda: str(uuid.uuid4()))

    level: int = Field(
        ..., description="Level of the section. 1 is top-level, 2 is second-level, etc."
    )
    """Level of this section. 1 is top-level, 2 is second-level, etc."""

    heading: str = Field(..., description="Heading of this section.")
    """Heading of this section."""

    text: str = Field(..., description="Text of this section.")
    """Text of this section."""

    parent: Optional["MarkdownSection"] = Field(
        default=None, description="Parent section of this section, if any."
    )
    """Parent section of this section, if any."""

    children: List["MarkdownSection"] = Field(
        default_factory=list, description="Child sections of this section."
    )
    """Child sections of this section."""

    def model_post_init(self, _: Any) -> None:
        """Post-initialization method for the model."""
        # Set as a child of the parent if it exists
        if self.parent:
            self.parent.children.append(self)

    @property
    def entire_text(self) -> str:
        """Get the entire text of the section, including the heading and children."""
        return f"{self.generate_entire_text()}\n"

    def generate_entire_text(self) -> str:
        """Generate the entire text of the section, including the heading and children."""

        entire_text = f"{'#' * self.level} {self.heading}"

        current_text = self.text.strip()
        if len(current_text) > 0:
            entire_text += f"\n\n{current_text}"

        for child in self.children:
            entire_text += f"\n\n{child.generate_entire_text()}"

        return entire_text


class MarkdownDocument(BaseModel):
    """Represents a Markdown document."""

    sections: List[MarkdownSection] = Field(default_factory=list)
    """List of sections in the document."""

    @property
    def top_level_sections(self) -> List[MarkdownSection]:
        """Get top-level sections of this document."""

        # First find the value of top-level
        top_level = min([section.level for section in self.sections])

        # Then return all sections with that level
        return [section for section in self.sections if section.level == top_level]

    def serialize_to_json(self, *, indent: int = 2) -> str:
        """Serialize a `MarkdownDocument` object to a JSON string.

        We can't use Pydantic's `model_dump_json()` method because it doesn't handle
        circular references between the `MarkdownSection` objects.

        Args:
            md_doc (MarkdownDocument): The `MarkdownDocument` object to serialize.

        Returns:
            str: The JSON string representation of the `MarkdownDocument` object.
        """
        raw_data = dict()

        raw_data["sections"] = [
            {
                "id": section.id,
                "level": section.level,
                "heading": section.heading,
                "text": section.text,
                "parent_id": section.parent.id if section.parent else None,
                "children_ids": [child.id for child in section.children],
            }
            for section in self.sections
        ]

        return json.dumps(raw_data, indent=indent)

    @classmethod
    def deserialize_from_json(cls, json_data: str) -> "MarkdownDocument":
        """Deserialize a JSON string generated by `serialize_to_json()` to a
        `MarkdownDocument` object.

        Args:
            json_data (str): The JSON string to deserialize.

        Returns:
            MarkdownDocument: The deserialized `MarkdownDocument` object.
        """

        raw_data = json.loads(json_data)

        lookup_id_to_section: Dict[str, MarkdownSection] = {}
        lookup_id_to_parent_id: Dict[str, str] = {}

        # Deserialize sections first
        for section_dict in raw_data["sections"]:
            section = MarkdownSection(
                id=section_dict["id"],
                level=section_dict["level"],
                heading=section_dict["heading"],
                text=section_dict["text"],
                parent=None,
                children=[],
            )
            lookup_id_to_section[section.id] = section

            # Keep track of parent ids for linking later
            lookup_id_to_parent_id[section.id] = section_dict["parent_id"]

        # Build parent-child relationships
        for id, parent_id in lookup_id_to_parent_id.items():
            if parent_id:
                section = lookup_id_to_section[id]
                parent = lookup_id_to_section[parent_id]
                section.parent = parent
                parent.children.append(section)

        # Finally, create the `MarkdownDocument` object
        md_doc = MarkdownDocument(
            sections=list(lookup_id_to_section.values()),
        )

        return md_doc


class GeneratedQuestion(BaseModel):
    """A generated question."""

    question: str = Field(
        ...,
        description="The question asking for the key information in the given section.",
    )

    section_id: str = Field(
        ..., description="The ID of the section from which the question was generated."
    )

    section_heading: str = Field(
        ...,
        description="The heading of the section from which the question was generated.",
    )

    phrases: List[str] = Field(
        ...,
        description="The key phrases in the section that provide the answer to the question in the given section.",
    )

    reference_answers: List[str] = Field(
        default_factory=list,
        description="The reference answers to the question.",
    )


class SyntheticQuestionSet(BaseModel):
    questions: List[GeneratedQuestion] = Field(
        default_factory=list, description="The set of generated questions."
    )


class ChunkedText(BaseModel):
    id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="A unique identifier of this chunk.",
    )
    """A unique identifier of this chunk."""

    section_id: str = Field(..., description="Which section this chunk belongs to.")
    """Which section this chunk belongs to."""

    text: str = Field(..., description="The text of this chunk.")
    """The text of this chunk."""


class ChunkingMethod(StrEnum):
    NAIVE = "naive"
    PARAGRAPH = "paragraph"


class ChunkedTextSet(BaseModel):
    chunking_method: ChunkingMethod = Field(
        ..., description="The method used to chunk the text."
    )
    """The method used to chunk the original text."""

    chunks: List[ChunkedText] = Field(
        default_factory=list, description="The set of chunked texts."
    )
    """The set of all chunks."""


class MatchedChunk(BaseModel):
    chunk_id: str = Field(..., description="ID of the chunk.")
    """ID of the chunk."""

    section_id: str = Field(..., description="ID of the section.")

    chunk_text: str = Field(..., description="Text of the chunk.")
    """Text of the chunk."""

    rank: int = Field(..., description="Rank of the match.")

    score: float = Field(..., description="Score of the match.")
    """Score of the match."""


class SearchResult(BaseModel):
    """Represents a search result."""

    query: str = Field(..., description="Query string.")

    matches: List[MatchedChunk] = Field(
        default_factory=list, description="List of matched chunks."
    )


class AnnotatedItem(BaseModel):
    id: str = Field(
        default_factory=lambda: str(uuid.uuid4()), description="A unique identifier."
    )
    """A unique identifier."""

    question: str = Field(..., description="The question to be answered.")
    """The question to be answered."""

    relevant_section_ids: Set[str] = Field(
        default_factory=set,
        description="IDs of relevant sections that contains the answer.",
    )
    """IDs of relevant sections that contains the answer."""

    relevant_chunk_ids: Set[str] = Field(
        default_factory=set,
        description="IDs of relevant chunks that answer the question.",
    )
    """IDs of relevant chunks that answer the question."""

    answer: Optional[str] = Field(
        default=None, description="The answer to the question."
    )
    """The answer to the question."""


class AnnotationSet(BaseModel):
    items: List[AnnotatedItem] = Field(
        default_factory=list, description="List of annotated items."
    )
    """List of annotated items."""


class MetricScore(BaseModel):
    name: str = Field(..., description="Name of the evaluation metric.")
    value: float = Field(..., description="Value of the evaluation metric.")


class EvaluatedQuery(BaseModel):
    annotation_id: str = Field(..., description="ID of the annotation item.")

    question: str = Field(..., description="Query string.")

    relevant_chunk_ids: Set[str] = Field(
        default_factory=set,
        description="IDs of relevant chunks that answer the question.",
    )

    retrieved_chunks: List[MatchedChunk] = Field(
        default_factory=list,
        description="List of retrieved chunks.",
    )

    metric_scores: Dict[str, MetricScore] = Field(
        default_factory=dict, description="Dictionary of metric scores for this query."
    )


class RetrievalEvaluation(BaseModel):
    k_values: List[int] = Field(
        default_factory=list,
        description="List of k values used for this evaluation.",
    )

    measures: Set[str] = Field(
        default_factory=set,
        description="Set of measures used for this evaluation.",
    )

    queries: List[EvaluatedQuery] = Field(
        default_factory=list, description="List of evaluated queries."
    )

    mean_metric_scores: Dict[str, float] = Field(
        default_factory=dict, description="Mean metric scores for the evaluation."
    )


class QueryRetrievalMetric(BaseModel):
    """Represents an evaluation metric for a specific query."""

    query_id: str = Field(..., description="ID of the query.")
    query: str = Field(..., description="Query string.")
    measure_name: str = Field(..., description="Name of the evaluation metric.")
    k: Optional[int] = Field(
        default=None, description="Which k value this metric is for."
    )
    value: float = Field(..., description="Value of the evaluation metric.")


class RetrievalPerformance(BaseModel):
    """Represents the performance of a retrieval system."""

    metrics: List[QueryRetrievalMetric] = Field(
        default_factory=list, description="Evaluation metrics."
    )

    @property
    def metrics_dict(self) -> Dict[str, List[QueryRetrievalMetric]]:
        result: Dict[str, List[QueryRetrievalMetric]] = defaultdict(list)
        for metric in self.metrics:
            result[metric.query_id].append(metric)
        return result

    @property
    def query_ids(self) -> List[str]:
        return list({metric.query_id for metric in self.metrics})
